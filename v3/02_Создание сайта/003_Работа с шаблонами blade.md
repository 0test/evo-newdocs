# Работа с blade-шаблонами в Evolution CMS #

1. [Введение](#section1)
2. [Базовый шаблон](#section2)
3. [Дочерние шаблоны](#section3)
4. [Переменные и данные](#section4)
5. [Директивы](#section5)




## Введение  <a name="section1"></a> ##

Стандартный шаблонизатор в Evolution CMS это **Blade** - движок шаблонов, входящий в состав Laravel.

Файлы шаблонов Blade используют расширение файла `.blade.php` и обычно хранятся в каталоге `/views` в корневой директории сайта.


## Базовый шаблон <a name="section2"></a> ##

После создания шаблонов в админ-панели папка `views` имеет следующий вид:

![Blade шаблоны](/assets/images/s9.png)

У нас созданы файлы `name.blade.php` для каждого из шаблонов. Если это не так, вы можете вручную создать файлы, определив в админ-панели, какой псевдоним задан шаблону.

**Изучите макет сайта**

Большинство сайтов имеют общий макет на всех страницах. Этот макет отличается только различным содержимым в контенте, сайдбаре и прочих секциях.

Чтобы не создавать множество одинаковых шаблонов, удобно определить этот макет как базовый шаблон Blade, от которого в дальнейшем мы будем наследовать другие шаблоны.

Создайте папку `layout` и в ней файл `app.blade.php` со следующим содержимым:
```html
<html>
<head>
    <title>@yield('title')</title>
</head>
<body>
    @section('sidebar')
    @show
    <main class="container">
        @yield('content')
    </main>
</body>
</html>
```

### Yield  и Section ###

Обратите внимание на директивы `@section` и `@yield`. 

Директива `@section` определяет секцию содержимого. Шаблоны, расширяющие макет, могут добавлять содержимое в секции макета с помощью директив `@section`. В нашем примере директива определяет, что в этом месте может быть определена секция сайдбара.
> Если директива не определена в дочернем шаблоне, то будет использовано значение по-умолчанию, которое у нас пустое.

Директива `@yield` используется для отображения содержимого секции, которое будет задано дочерним шаблоном. 

>Ближайшая аналогия `@yield` -- это вывод переменной, значение которой мы зададим для каждого дочернего шаблона.

## Дочерние шаблоны <a name="section3"></a> ##

Сделаем дочерний шаблон, который наследует базовый макет.

Найдите шаблон `mainpage.blade.php` и измените его содержимое:

```html
@extends('layout.app')
@section('title', 'Главная страница')
@section('sidebar')
	<aside>
		<p>Сайдбар для главной</p>
	</aside>
@endsection
@section('content')
	<p>Контент</p>
@endsection
```

### Extends  ###

Мы использовали используйте директиву `@extends`, чтобы указать, какой макет этот шаблон должен наследовать. В нашем случае наследуется `layout/app.blade.php` - наш базовый шаблон.

>Точка означает, что файл app лежит в папке layout. А .blade.php можно не дописывать. Для указания вложенности используется «точечная нотация».

Директивы `@section` присваивают содержимое секциям, которые заданы в родительском шаблоне с помощью `@yield`.

Обратите внимание на два способа написания директивы:
```html
@section('title', 'Главная страница')
```
и
```html
@section('content')
 <!-- any html -->
@endsection 
```
Какой способ выбрать - вопрос исключительно вашего удобства и количества содержимого.

Разумеется, мы можем и не задавать какую-то `@section`. Скажем, если для других страниц нужно скрыть сайдбар, то достаточно убрать его `section`:

```html
@extends('layout.app')
@section('title', 'Неглавная страница')
@section('content')
<p>Контент страниц без сайдбара</p>
@endsection
```

### include ###

Если вы хотите **всегда** включать в шаблон какой-то блок, воспользуйтесь  директивой `@include`.

Допустим, на сайте всегда одинаковый футер. Создайте файл `footer.blade.php` в папке `parts`:

```html
<footer>Нижняя часть сайта</footer>
```

Подключите его в файле `layouts/app.blade.php`:
```html
@include('parts.footer')
```
Теперь содержимое файла `parts/footer.blade.php` будет всегда отображаться на всех страницах, наследующих `app.blade.php`.

> В `@include` можно передавать данные, подробности в расширенном материале про шаблонизацию.

## Переменные и данные <a name="section4"></a> ##

Подробнее о том, как отдать шаблону данные, мы разберём в материале [Контроллеры](/v3/02_%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%81%D0%B0%D0%B9%D1%82%D0%B0/005_%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%BB%D0%B5%D1%80%D1%8B.md).

Вы можете отобразить содержимое переменной `name` следующим образом:

```
Hello, {{ $name }}.

```
#### Экранирование ####
Выражения `{{ }}` автоматически обрабатываются функцией htmlspecialchars для предотвращения XSS-атак. Если вы не хотите, чтобы ваши данные были экранированы, вы можете использовать следующий синтаксис:
```
Hello, {!! $name !!}.
```
#### Вызов методов Evolution CMS ####

Таким же образом можно получить доступ к различным объектам, предоставляемым системой.
```
{!! $modx->getConfig('site_name) !!}
```
```
{!! $modx->runSnippet('DocLister', [
	'parent' => 1,
	'tpl' => 'parts.one_item'
])!!}
```



## Директивы <a name="section5"></a> ##

Помимо наследования шаблонов и отображения данных, Blade содержит псевдонимы для условных операторов и циклов.

Эти директивы схожи со своими аналогами в PHP: if, else, for, foreach и прочие.

Если вам нужны дополнительные сведения, прочитайте [подробный материал про шаблоны](/v3/03_%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5/001_Шаблоны%20в%20Evolution%20CMS.md) в Evolution CMS.

А теперь переходите к созданию [первого пакета](/v3/02_%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%81%D0%B0%D0%B9%D1%82%D0%B0/004_%D0%A1%D1%82%D0%B0%D1%80%D1%82%D0%BE%D0%B2%D1%8B%D0%B9%20%D0%BF%D0%B0%D0%BA%D0%B5%D1%82.md) и работе с контроллерами.
