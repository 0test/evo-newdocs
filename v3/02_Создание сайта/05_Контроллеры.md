# Контроллеры в Evolution CMS #

Контроллер - это класс, который обрабатывает входящие запросы и отдаёт данные в представление.

1. [Принципы работы](#section2)
2. [Общая информация](#section1)
	1. Базовый контроллер
	2. Контроллер для шаблона
	3. Контроллер для произвольного маршрута (TODO)

## Принципы работы  <a name="section2"></a> ##

В Laravel контроллер работает в связке `маршрут-контроллер-представление`.
Это означает, что мы назначаем определённому маршруту на сайте свой контроллер. Контроллер, в свою очередь, отдаёт нужные данные в представление. Таким образом формируется страница сайта.

В Evolution CMS контроллеры работают иначе.

Связь осуществляется через поле шаблона `псевдоним`.

![Alias](/assets/images/s10.png)

> Для шаблона с псевдонимом `main` соответствующее название контроллера  `MainController.php`

Символ подчёркивания вырезается.

> Для шаблона с псевдонимом `news_main` соответствующее название контроллера  `NewsMainController.php`

**В псевдониме желательно использовать только буквы и подчёркивание.**


Таким образом, контроллер отдаёт данные в шаблон, минуя маршруты. 

Такое поведение обусловлено тем, что маршрутизация у CMS своя, и данные логично отдавать именно в шаблоны, поскольку функционал и дизайн сайта базируются как раз на шаблоне, как на логической единице дизайна.

Стоит заметить, что возможно сделать "классическое" поведение контроллеров. Смотрите раздел про контроллеры для произвольных маршрутов.

## Общая информация  <a name="section1"></a> ##


### Файлы контроллеров ###
Контроллеры располагаются в папке `core/custom/packages/main/src/` где `main` это название вашего пакета.

### Пространство имён ###
Укажите в настройках CMS Controller Namespace для ваших контроллеров.
Мы создали стартовый пакет `main`, поэтому указываем `EvolutionCMS\Main\Controllers\`

![Пространство имён](/assets/images/s11.png)



### Базовый контроллер ###

При работе с контроллерами стоит сделать базовый контроллер, от которого унаследовать все остальные контроллеры сайта.

Это удобно, т.к. зачастую возникает необходимость реализовать выдачу каких-то данных сразу всем шаблонам. 
Базовый контроллер позволяет сделать это в одном файле.

**Пример базового контроллера**

Создайте файл

```
core/custom/packages/main/src/Controllers/BaseController.php
```

```php
<?php
namespace EvolutionCMS\Main\Controllers;
use Illuminate\Support\Facades\Cache;

class BaseController
{
	//	в эту переменную добавляйте данные,
	//	которые хотите отдать в шаблоны
    public $data = [];

    public function __construct()
    {
		//	подключаем функции CMS
        $this->evo = EvolutionCMS();
        ksort($_GET);
        $cacheid = md5(json_encode($_GET));
		 //	если включен кэш на сайте,
		 //	получаем данные из кэша
		 //	rememberForever - метод Laravel, см. документацию
        if ($this->evo->getConfig('enable_cache')) {
            $this->data = Cache::rememberForever($cacheid, function () {
                $this->globalElements();
                $this->render();
                return $this->data;
            });
        } else {
            $this->globalElements();
            $this->render();
        }
        $this->noCacheRender();
        $this->sendToView();
    }
    public function render()
    {
		//	использовать для отдачи данных
    }
    public function noCacheRender()
    {
		// использовать для отдачи некэшированных данных
    }

    public function globalElements()
    {
		//	тут можно отдать элементы,
		//	одинаковые для всех шаблонов
    }

    public function sendToView()
    {
		//	отдаём данные в шаблон
        $this->evo->addDataToView($this->data);
    }
}

```

Разумеется, вы можете дописать сюда необходимые вам методы.

>Не стоит писать ничего в методы `render` и `noCacheRender` - в дальнейшем мы их переопределим в контроллерах шаблонов.



### Контроллер для шаблона ###

Давайте определим контроллер для шаблона всех новостей. Задача - вывести дочерние материалы из ресурса "Новости".

Ресурс "Новости" имеет шаблон "Новости - главная".
![Шаблон](/assets/images/s12.png)

Шаблон "Новости-главная" имеет псевдоним `news_main`

![Alias](/assets/images/s10.png)

Создаём файл контроллера `NewsMainController` для этого шаблона 

```
core/custom/packages/main/src/Controllers/NewsMainController.php
```


```php
<?php 
namespace EvolutionCMS\Main\Controllers;

class NewsMainController extends BaseController{


	public function render()
    {
       //	Переопределяем метод из BaseController
    }
}
```

Мы наследовали `BaseController` и можем использовать и переопределять его методы. 

#### Вариант 1 ####

Давайте получим новости из раздела "Новости" и отдадим их шаблону.
```php
	public function render()
    {
		 $this->data['news'] = $this->evo->runSnippet('DocLister',[
            'parents' => 4,
            'depth' => 1,
			'tpl' => '@B_FILE: parts.one_news'
		]);     
    }
```
Мы воспользовались методом runSnippet из api Evolution CMS и заранее установленным сниппетом `DocLister`, чтобы получить данные.

Параметр `tpl` необходим для шаблонизации каждой выведенной новости и содержит путь к файлу blade
```
views/parts/one_news.blade.php
```
Содержимое файла может быть, например, таким:

```html
<article>
	<h1>
		<a href="@makeUrl($data['id'] )">
		{{ $data['title'] }}
		</a>
	</h1>
</article>
```
> Откуда взялась `$data['title']`? Это переменная самого DocLister'а, которую он отдаёт в свои шаблоны. Отношения к контроллеру и к его переменной `$data` она не имеет.

Осталось вывести данные в шаблон новостей.

Вернитесь к листингу метода `render` и обратите внимание на то, что мы добавляем значение `news` в  `$this->data`.

Получить значение переменной в шаблоне очень просто:
```
views/news_main.blade.php
```

```html
@extends('layout.app')
@section('title', 'Новости')

@section('content')
	<p>Лента новостей:</p>
	{!! $news !!}
@endsection
```


#### Вариант 2 ####


>Приведённый пример работоспособен и, в принципе, пригоден для "боевого" использования. Однако он всё же нарушает принцип MVC, так как отдаёт не данные, а верстку.

Мы можем это исправить.

Давайте сделаем так, чтобы контроллер отдал только данные.

```php 

	public function render()
    {
		$_news = $this->evo->runSnippet('DocLister',[
            'parents' => 4,
            'depth' => 1,
            'api' => 1,
		]);
        $this->data['news'] = json_decode($_news,1);
        return $this->data['news'] ;
    }
```
Мы добавили параметр `api` для сниппета DocLister, чтобы он не отдавал нам html, а отдал строку. Кодируем это строку так, чтобы на выходе получился массив.

И отдаём массив в же переменную `news`.

Теперь мы можем работать с ней в шаблоне при помощи директив blade:

```
views/news_main.blade.php
```
```html
@foreach ($news as $one_news)
	<article>
		<h1>
			<a href="@makeUrl($one_news['id'] )">
			{{ $one_news['title'] }}
			</a>
		</h1>
	</article>
@endforeach
```

Эту конструкцию можно ещё более упростить, если вынести разметку новости в отдельный файл и передавать ей только данные.

Воспользуемся директивой `@include`:

```
	@foreach ($news as $one_news)	
		@include('parts.one_news',[ 'data' => $one_news] )
	@endforeach
```	

### Контроллер для произвольного маршрута ###

Вы можете перейти к классической схеме, где контроллер обрабатывает данные маршрута и отдаёт представление.

Но это напишет кто-то другой. Или не напишет.



